
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorials/ch1_fundamentals/ch1_3a_grids.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorials_ch1_fundamentals_ch1_3a_grids.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorials_ch1_fundamentals_ch1_3a_grids.py:


1.3a: Grids.
============

.. GENERATED FROM PYTHON SOURCE LINES 5-14

.. code-block:: Python


    import numpy as np
    import matplotlib.pyplot as plt

    import gempy as gp
    from gempy.core.data import Grid

    np.random.seed(55500)








.. GENERATED FROM PYTHON SOURCE LINES 15-22

The Grid Class
--------------

The grid class will interact with the rest of data classes and grid
subclasses. Its main purpose is to feed coordinates XYZ to the
interpolator.


.. GENERATED FROM PYTHON SOURCE LINES 24-26

.. code-block:: Python

    grid = Grid()








.. GENERATED FROM PYTHON SOURCE LINES 27-32

The most important attribute of Grid is ``values`` (and ``values_r``
which are the values rescaled) which are the 3D points in space that
kriging will be evaluated on. This array will be feed by "grid types" on
a **composition** relation with Grid:


.. GENERATED FROM PYTHON SOURCE LINES 35-37

.. image:: /_static/grids.jpg


.. GENERATED FROM PYTHON SOURCE LINES 39-41

.. code-block:: Python

    grid.values, grid.values_r





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (array([], shape=(0, 3), dtype=float64), array([], shape=(0, 3), dtype=float64))



.. GENERATED FROM PYTHON SOURCE LINES 42-46

At the moment of writing this tutorial, there is 5 grid types. The
number of grid types is scalable and down the road we aim to connect
other grid packages (like `Discretize <https://pypi.org/project/discretize/>`_) as an extra Grid type


.. GENERATED FROM PYTHON SOURCE LINES 48-50

.. code-block:: Python

    grid.grid_types





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array(['regular', 'custom', 'topography', 'sections', 'centered'],
          dtype='<U10')



.. GENERATED FROM PYTHON SOURCE LINES 51-54

Each grid contains its own ``values`` attribute as well as other
methods to manipulate them depending on the type of grid.


.. GENERATED FROM PYTHON SOURCE LINES 56-58

.. code-block:: Python

    grid.regular_grid.values





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([], shape=(0, 3), dtype=float64)



.. GENERATED FROM PYTHON SOURCE LINES 59-62

We can see what grids are activated (i.e. they are going to be
interpolated and therefore will live on ``Grid().values``) by:


.. GENERATED FROM PYTHON SOURCE LINES 64-66

.. code-block:: Python

    grid.active_grids_bool





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([False, False, False, False, False])



.. GENERATED FROM PYTHON SOURCE LINES 67-70

By default only the *regular grid* (``grid.regular_grid``\ ) is active. However, since the regular
grid is still empty ``Grid().values`` is empty too.


.. GENERATED FROM PYTHON SOURCE LINES 72-74

.. code-block:: Python

    grid.values





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([], shape=(0, 3), dtype=float64)



.. GENERATED FROM PYTHON SOURCE LINES 75-77

The last important attribute of Grid is the length:


.. GENERATED FROM PYTHON SOURCE LINES 79-81

.. code-block:: Python

    grid.length





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([0, 0, 0, 0, 0, 0])



.. GENERATED FROM PYTHON SOURCE LINES 82-88

Length gives back the interface indices between grids on the
``Grid().values`` attribute. This can be used after interpolation to
know which interpolated values and coordinates correspond to each grid
type. You can use the method get\_grid\_args to return the indices by
name:


.. GENERATED FROM PYTHON SOURCE LINES 90-92

.. code-block:: Python

    grid.get_grid_args('topography')





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (0, 0)



.. GENERATED FROM PYTHON SOURCE LINES 93-96

By now all is a bit confusing because we have no values. Lets start
adding values to the different grids:


.. GENERATED FROM PYTHON SOURCE LINES 99-105

Regular grid
~~~~~~~~~~~~

The ``Grid`` class has a bunch of methods to set each grid type and
activate them.


.. GENERATED FROM PYTHON SOURCE LINES 107-109

.. code-block:: Python

    help(grid.create_regular_grid)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Help on method create_regular_grid in module gempy.core.data.grid:

    create_regular_grid(extent=None, resolution=None, set_active=True, *args, **kwargs) method of gempy.core.data.grid.Grid instance
        Set a new regular grid and activate it.
    
        Args:
            extent (np.ndarray): [x_min, x_max, y_min, y_max, z_min, z_max]
            resolution (np.ndarray): [nx, ny, nz]
    
        RegularGrid Docs





.. GENERATED FROM PYTHON SOURCE LINES 110-112

.. code-block:: Python

    grid.create_regular_grid(extent=[0, 100, 0, 100, -100, 0], resolution=[20, 20, 20])





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    <gempy.core.data.grid_modules.grid_types.RegularGrid object at 0x7f088aa13160>



.. GENERATED FROM PYTHON SOURCE LINES 113-115

Now the regular grid object composed on ``Grid`` has been filled:


.. GENERATED FROM PYTHON SOURCE LINES 117-119

.. code-block:: Python

    grid.regular_grid.values





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([[  2.5,   2.5, -97.5],
           [  2.5,   2.5, -92.5],
           [  2.5,   2.5, -87.5],
           ...,
           [ 97.5,  97.5, -12.5],
           [ 97.5,  97.5,  -7.5],
           [ 97.5,  97.5,  -2.5]])



.. GENERATED FROM PYTHON SOURCE LINES 120-123

And the regular grid has been set active (it was already active in any
case):


.. GENERATED FROM PYTHON SOURCE LINES 125-127

.. code-block:: Python

    grid.active_grids_bool





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([ True, False, False, False, False])



.. GENERATED FROM PYTHON SOURCE LINES 128-130

Therefore the grid values will be equal to the regular grid:


.. GENERATED FROM PYTHON SOURCE LINES 132-134

.. code-block:: Python

    grid.values





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([[  2.5,   2.5, -97.5],
           [  2.5,   2.5, -92.5],
           [  2.5,   2.5, -87.5],
           ...,
           [ 97.5,  97.5, -12.5],
           [ 97.5,  97.5,  -7.5],
           [ 97.5,  97.5,  -2.5]])



.. GENERATED FROM PYTHON SOURCE LINES 135-137

And the indices to extract the different arrays:


.. GENERATED FROM PYTHON SOURCE LINES 139-141

.. code-block:: Python

    grid.length





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([   0, 8000, 8000, 8000, 8000, 8000])



.. GENERATED FROM PYTHON SOURCE LINES 142-147

Custom grid
~~~~~~~~~~~

Completely free XYZ values.


.. GENERATED FROM PYTHON SOURCE LINES 149-151

.. code-block:: Python

    gp.set_custom_grid(grid, np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Active grids: ['regular' 'custom']

    <gempy.core.data.grid_modules.grid_types.CustomGrid object at 0x7f088aa10790>



.. GENERATED FROM PYTHON SOURCE LINES 152-155

Again ``set_any_grid`` will create a grid and activate it. So now the
compose object will contain values:


.. GENERATED FROM PYTHON SOURCE LINES 157-159

.. code-block:: Python

    grid.custom_grid.values





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]])



.. GENERATED FROM PYTHON SOURCE LINES 160-162

and since it is active, will be added to the grid.values stack:


.. GENERATED FROM PYTHON SOURCE LINES 164-166

.. code-block:: Python

    grid.active_grids_bool





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([ True,  True, False, False, False])



.. GENERATED FROM PYTHON SOURCE LINES 167-169

.. code-block:: Python

    grid.values.shape





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (8000, 3)



.. GENERATED FROM PYTHON SOURCE LINES 170-173

We can still recover those values with ``get_grid`` or by getting the
slicing args:


.. GENERATED FROM PYTHON SOURCE LINES 175-177

.. code-block:: Python

    grid.get_grid('custom')





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([], shape=(0, 3), dtype=float64)



.. GENERATED FROM PYTHON SOURCE LINES 178-181

.. code-block:: Python

    l0, l1 = grid.get_grid_args('custom')
    l0, l1





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (8000, 8000)



.. GENERATED FROM PYTHON SOURCE LINES 182-184

.. code-block:: Python

    grid.values[l0:l1]





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([], shape=(0, 3), dtype=float64)



.. GENERATED FROM PYTHON SOURCE LINES 185-192

Topography
~~~~~~~~~~

Now we can set the topography. :class:`Topography <gempy.core.grid_modules.topography.Topography>`
contains methods to create manual topographies as well as gdal for
dealing with raster data. By default we will create a random topography:


.. GENERATED FROM PYTHON SOURCE LINES 194-196

.. code-block:: Python

    gp.set_topography_from_random(grid)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    [-20.   0.]
    Active grids: ['regular' 'custom' 'topography']

    <gempy.core.data.grid_modules.topography.Topography object at 0x7f088aa11d50>



.. GENERATED FROM PYTHON SOURCE LINES 197-199

.. code-block:: Python

    grid.active_grids_bool





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([ True,  True,  True, False, False])



.. GENERATED FROM PYTHON SOURCE LINES 200-202

Now the grid values will contain both the regular grid and topography:


.. GENERATED FROM PYTHON SOURCE LINES 204-206

.. code-block:: Python

    grid.values, grid.length





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (array([[  2.5,   2.5, -97.5],
           [  2.5,   2.5, -92.5],
           [  2.5,   2.5, -87.5],
           ...,
           [ 97.5,  97.5, -12.5],
           [ 97.5,  97.5,  -7.5],
           [ 97.5,  97.5,  -2.5]]), array([   0, 8000, 8000, 8000, 8000, 8000]))



.. GENERATED FROM PYTHON SOURCE LINES 207-209

The topography args are got as follows:


.. GENERATED FROM PYTHON SOURCE LINES 211-214

.. code-block:: Python

    l0, l1 = grid.get_grid_args('topography')
    l0, l1





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (8000, 8000)



.. GENERATED FROM PYTHON SOURCE LINES 215-217

And we can slice the values array as any other numpy array:


.. GENERATED FROM PYTHON SOURCE LINES 219-221

.. code-block:: Python

    grid.values[l0: l1]





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([], shape=(0, 3), dtype=float64)



.. GENERATED FROM PYTHON SOURCE LINES 222-224

We can compare it to the topography.values:


.. GENERATED FROM PYTHON SOURCE LINES 226-228

.. code-block:: Python

    grid.topography.values





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([[  0.        ,   0.        , -14.23224119],
           [  0.        ,   5.26315789, -14.18893341],
           [  0.        ,  10.52631579, -13.54018217],
           ...,
           [100.        ,  89.47368421, -14.13839552],
           [100.        ,  94.73684211, -16.12793911],
           [100.        , 100.        , -16.21462612]])



.. GENERATED FROM PYTHON SOURCE LINES 229-232

Now that we have more than one grid we can activate and deactivate any
of them in real time:


.. GENERATED FROM PYTHON SOURCE LINES 234-237

.. code-block:: Python

    grid.set_inactive('topography')
    grid.set_inactive('regular')





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([False,  True, False, False, False])



.. GENERATED FROM PYTHON SOURCE LINES 238-240

Since now all grids are deactivated the values will be empty:


.. GENERATED FROM PYTHON SOURCE LINES 242-244

.. code-block:: Python

    grid.values





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([[1., 2., 3.],
           [4., 5., 6.],
           [7., 8., 9.]])



.. GENERATED FROM PYTHON SOURCE LINES 245-247

.. code-block:: Python

    grid.set_active('topography')





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([False,  True,  True, False, False])



.. GENERATED FROM PYTHON SOURCE LINES 248-250

.. code-block:: Python

    grid.values, grid.values.shape





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    (array([[  1.        ,   2.        ,   3.        ],
           [  4.        ,   5.        ,   6.        ],
           [  7.        ,   8.        ,   9.        ],
           ...,
           [100.        ,  89.47368421, -14.13839552],
           [100.        ,  94.73684211, -16.12793911],
           [100.        , 100.        , -16.21462612]]), (403, 3))



.. GENERATED FROM PYTHON SOURCE LINES 251-253

.. code-block:: Python

    grid.set_active('regular')





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([ True,  True,  True, False, False])



.. GENERATED FROM PYTHON SOURCE LINES 254-256

.. code-block:: Python

    grid.values





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


    array([[  2.5       ,   2.5       , -97.5       ],
           [  2.5       ,   2.5       , -92.5       ],
           [  2.5       ,   2.5       , -87.5       ],
           ...,
           [100.        ,  89.47368421, -14.13839552],
           [100.        ,  94.73684211, -16.12793911],
           [100.        , 100.        , -16.21462612]])



.. GENERATED FROM PYTHON SOURCE LINES 257-266

Centered Grid
~~~~~~~~~~~~~

This grid contains an irregular grid where the majority of voxels are
centered around a value (or values). This type of grid is usually used
to compute certain types of forward physics where the influence
decreases with distance (e.g. gravity: Check `tutorial 2.2-Cell-selection <https://github.com/cgre-aachen/gempy/blob/master/examples/tutorials/ch2-Geophysics/ch2_2_cell_selection.py>`_
)


.. GENERATED FROM PYTHON SOURCE LINES 268-275

.. code-block:: Python

    gp.set_centered_grid(
        grid,
        centers=np.array([[300, 0, 0], [0, 0, 0]]),
        resolution=[10, 10, 20],
        radius=np.array([100, 100, 100])
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Active grids: ['regular' 'custom' 'topography' 'centered']

    CenteredGrid(centers=array([[300,   0,   0],
           [  0,   0,   0]]), resolution=[10, 10, 20], radius=array([100, 100, 100]), kernel_grid_centers=array([[-100.        , -100.        ,   -6.        ],
           [-100.        , -100.        ,   -7.2       ],
           [-100.        , -100.        ,   -7.52912998],
           ...,
           [ 100.        ,  100.        ,  -79.90178533],
           [ 100.        ,  100.        , -100.17119644],
           [ 100.        ,  100.        , -126.        ]]), left_voxel_edges=array([[ 34.1886117 ,  34.1886117 ,  -0.6       ],
           [ 34.1886117 ,  34.1886117 ,  -0.6       ],
           [ 34.1886117 ,  34.1886117 ,  -0.16456499],
           ...,
           [ 34.1886117 ,  34.1886117 ,  -7.95331123],
           [ 34.1886117 ,  34.1886117 , -10.13470556],
           [ 34.1886117 ,  34.1886117 , -12.91440178]]), right_voxel_edges=array([[ 34.1886117 ,  34.1886117 ,  -0.6       ],
           [ 34.1886117 ,  34.1886117 ,  -0.16456499],
           [ 34.1886117 ,  34.1886117 ,  -0.20970105],
           ...,
           [ 34.1886117 ,  34.1886117 , -10.13470556],
           [ 34.1886117 ,  34.1886117 , -12.91440178],
           [ 34.1886117 ,  34.1886117 , -12.91440178]]))



.. GENERATED FROM PYTHON SOURCE LINES 276-280

Resolution and radius create a geometric spaced kernel (blue dots) which
will be use to create a grid around each of the center points (red
dots):


.. GENERATED FROM PYTHON SOURCE LINES 282-311

.. code-block:: Python


    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')

    ax.scatter(
        grid.centered_grid.values[:, 0],
        grid.centered_grid.values[:, 1],
        grid.centered_grid.values[:, 2],
        '.',
        alpha=.2
    )

    ax.scatter(
        np.array([[300, 0, 0], [0, 0, 0]])[:, 0],
        np.array([[300, 0, 0], [0, 0, 0]])[:, 1],
        np.array([[300, 0, 0], [0, 0, 0]])[:, 2],
        c='r',
        alpha=1,
        s=30
    )

    ax.set_xlim(-100, 400)
    ax.set_ylim(-100, 100)
    ax.set_zlim(-120, 0)
    ax.set_xlabel('X Label')
    ax.set_ylabel('Y Label')
    ax.set_zlabel('Z Label')
    plt.show()




.. image-sg:: /tutorials/ch1_fundamentals/images/sphx_glr_ch1_3a_grids_001.png
   :alt: ch1 3a grids
   :srcset: /tutorials/ch1_fundamentals/images/sphx_glr_ch1_3a_grids_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 312-317

Section Grid
~~~~~~~~~~~~

This grid type has its own tutorial. See :doc: `ch1_3b_cross_sections`



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.078 seconds)


.. _sphx_glr_download_tutorials_ch1_fundamentals_ch1_3a_grids.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: ch1_3a_grids.ipynb <ch1_3a_grids.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: ch1_3a_grids.py <ch1_3a_grids.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
